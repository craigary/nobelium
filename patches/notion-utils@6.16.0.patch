diff --git a/build/index.js b/build/index.js
index d73a6aeddb8c86d0956f26e94b1afa933b142bb0..6c469e27eb322552df94e3362e1c74761a43f36c 100644
--- a/build/index.js
+++ b/build/index.js
@@ -1,2 +1,2 @@
-var q=Object.defineProperty,N=Object.defineProperties;var V=Object.getOwnPropertyDescriptors;var $=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,Q=Object.prototype.propertyIsEnumerable;var D=(e,t,o)=>t in e?q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,g=(e,t)=>{for(var o in t||(t={}))H.call(t,o)&&D(e,o,t[o]);if($)for(var o of $(t))Q.call(t,o)&&D(e,o,t[o]);return e},U=(e,t)=>N(e,V(t));var R=(e,t,o)=>new Promise((n,s)=>{var r=c=>{try{m(o.next(c))}catch(l){s(l)}},a=c=>{try{m(o.throw(c))}catch(l){s(l)}},m=c=>c.done?n(c.value):Promise.resolve(c.value).then(r,a);m((o=o.apply(e,t)).next())});var h=e=>{var t;return e?Array.isArray(e)?(t=e==null?void 0:e.reduce((o,n)=>o+(n[0]!=="\u204D"&&n[0]!=="\u2023"?n[0]:""),""))!=null?t:"":e:""};function w(e,t){var s,r,a,m,c,l,i;let o=e.collection_id||((r=(s=e.format)==null?void 0:s.collection_pointer)==null?void 0:r.id);if(o)return o;let n=(a=e==null?void 0:e.view_ids)==null?void 0:a[0];if(n){let u=(c=(m=t.collection_view)==null?void 0:m[n])==null?void 0:c.value;if(u)return(i=(l=u.format)==null?void 0:l.collection_pointer)==null?void 0:i.id}return null}function v(e,t){var o,n;if((o=e.properties)!=null&&o.title)return h(e.properties.title);if(e.type==="collection_view_page"||e.type==="collection_view"){let s=w(e,t);if(s){let r=(n=t.collection[s])==null?void 0:n.value;if(r)return h(r.name)}}return""}function B(e,t){var o,n,s;if((o=e.format)!=null&&o.page_icon)return(n=e.format)==null?void 0:n.page_icon;if(e.type==="collection_view_page"||e.type==="collection_view"){let r=w(e,t);if(r){let a=(s=t.collection[r])==null?void 0:s.value;if(a)return a.icon}}return null}function pe(e){var o;let t=(o=e.block[Object.keys(e.block)[0]])==null?void 0:o.value;return t?v(t,e):null}function P(e,t,o){var n;try{if(!t.properties||!Object.keys(o.collection))return null;let s=(n=o.collection[t.parent_id])==null?void 0:n.value;if(s){let r=e.toLowerCase(),a=Object.keys(s.schema).find(l=>{var i,u;return((u=(i=s.schema[l])==null?void 0:i.name)==null?void 0:u.toLowerCase())===r});if(!a)return null;let{type:m}=s.schema[a],c=h(t.properties[a]);switch(m){case"created_time":return t.created_time;case"multi_select":return c.split(",");case"date":{let i=t.properties[a][0][1][0][1];if(i.type=="datetime")return new Date(`${i.start_date} ${i.start_time}`).getTime();if(i.type=="date")return new Date(i.start_date).getTime();if(i.type=="datetimerange"){let{start_date:u,start_time:y,end_date:f,end_time:T}=i,b=new Date(`${u} ${y}`).getTime(),d=new Date(`${f} ${T}`).getTime();return[b,d]}else{let u=new Date(i.start_date).getTime(),y=new Date(i.end_date).getTime();return[u,y]}}case"checkbox":return c=="Yes";case"last_edited_time":return t.last_edited_time;default:return c}}}catch(s){}return null}var Y=e=>{if(e&&Array.isArray(e)){if(e[0]==="d")return e[1];for(let t of e){let o=Y(t);if(o)return o}}return null};var O=(e,t,{inclusive:o=!1}={})=>{var s,r;let n=e;for(;n!=null;){if(o&&(n==null?void 0:n.type)==="page")return n;let a=n.parent_id,m=n.parent_table;if(!a)break;if(m==="collection")n=(s=t.collection[a])==null?void 0:s.value;else if(n=(r=t.block[a])==null?void 0:r.value,(n==null?void 0:n.type)==="page")return n}return null};var Z={header:0,sub_header:1,sub_sub_header:2},S=(e,t)=>{var s;let o=((s=e.content)!=null?s:[]).map(r=>{var m,c;let a=(m=t.block[r])==null?void 0:m.value;if(a){let{type:l}=a;if(l==="header"||l==="sub_header"||l==="sub_sub_header")return{id:r,type:l,text:h((c=a.properties)==null?void 0:c.title),indentLevel:Z[l]}}return null}).filter(Boolean),n=[{actual:-1,effective:-1}];for(let r of o){let{indentLevel:a}=r,m=a;do{let c=n[n.length-1],{actual:l,effective:i}=c;if(m>l)r.indentLevel=i+1,n.push({actual:m,effective:r.indentLevel});else if(m===l){r.indentLevel=i;break}else n.pop()}while(!0)}return o};var Te=(e,t)=>{let o=t||Object.keys(e.block)[0],n=new Set;function s(r){var u,y,f,T;if(n.has(r))return;n.add(r);let a=(u=e.block[r])==null?void 0:u.value;if(!a)return;let{content:m,type:c,properties:l,format:i}=a;if(l)for(let b of Object.keys(l)){let d=l[b];d.map(k=>{var _,I;let p=(I=(_=k==null?void 0:k[0])==null?void 0:_[1])==null?void 0:I[0];(p==null?void 0:p[0])==="p"&&p[1]&&s(p[1])});let x=(f=(y=d==null?void 0:d[0])==null?void 0:y[1])==null?void 0:f[0];(x==null?void 0:x[0])==="p"&&x[1]&&s(x[1])}if(i){let b=(T=i.transclusion_reference_pointer)==null?void 0:T.id;b&&s(b)}if(!(!m||!Array.isArray(m))&&!(r!==o&&(c==="page"||c==="collection_view_page")))for(let b of m)s(b)}return s(o),Array.from(n)};var L=(e="")=>`${e.substr(0,8)}-${e.substr(8,4)}-${e.substr(12,4)}-${e.substr(16,4)}-${e.substr(20)}`;var G=/\b([a-f0-9]{32})\b/,J=/\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\b/,W=(e="",{uuid:t=!0}={})=>{if(!e)return null;e=e.split("?")[0];let o=e.match(G);if(o)return t?L(o[1]):o[1];let n=e.match(J);return n?t?n[1]:n[1].replace(/-/g,""):null};var M=e=>e.replace(/-/g,"");import K from"p-queue";function Ee(a,m,c){return R(this,arguments,function*(e,t,o,{concurrency:n=4,traverseCollections:s=!0,targetPageId:r=null}={}){let l={},i=new Set,u=new K({concurrency:n});function y(f){return R(this,null,function*(){r&&i.has(r)||(f=W(f),f&&!l[f]&&!i.has(f)&&(i.add(f),u.add(()=>R(this,null,function*(){var T,b;try{if(r&&i.has(r)&&f!==r)return;let d=yield o(f);if(!d)return;let x=(b=(T=d.block[f])==null?void 0:T.value)==null?void 0:b.space_id;if(x){if(!t)t=x;else if(t!==x)return}if(Object.keys(d.block).filter(k=>{var _;let p=(_=d.block[k])==null?void 0:_.value;return!(!p||p.type!=="page"&&p.type!=="collection_view_page"||t&&p.space_id&&p.space_id!==t)}).forEach(k=>y(k)),s)for(let k of Object.values(d.collection_query))for(let p of Object.values(k)){let{blockIds:_}=p;if(_)for(let I of _)y(I)}l[f]=d}catch(d){console.warn("page load error",{pageId:f,spaceId:t},d.statusCode,d.message),l[f]=null}i.delete(f)}))))})}return yield y(e),yield u.onIdle(),l})}var z=e=>(e||"").replace(/ /g,"-").replace(/[^a-zA-Z0-9-\u4e00-\u9FFF\u3041-\u3096\u30A1-\u30FC\u3000-\u303F]/g,"").replace(/--/g,"-").replace(/-$/,"").replace(/^-/,"").trim().toLowerCase();var We=(e,t,{uuid:o=!0}={})=>{var r;if(!e||!t)return null;let n=M(e),s=(r=t.block[e])==null?void 0:r.value;if(s){let a=P("slug",s,t)||P("Slug",s,t)||z(v(s,t));if(a)return o?`${a}-${n}`:a}return n};var je=(e,t)=>{var r;let o=e.block,n=[],s=t;do{let a=(r=o[s])==null?void 0:r.value;if(!a)break;let m=v(a,e),c=B(a,e);if(!(m||c))break;n.push({block:a,active:s===t,pageId:s,title:m,icon:c});let l=O(a,e),i=l==null?void 0:l.id;if(!i)break;s=i}while(!0);return n.reverse(),n};import A from"is-url-superb";var Ye=(e,{mapImageUrl:t})=>{let n=Object.keys(e.block).flatMap(s=>{var m,c,l,i,u,y,f,T,b,d,x;let r=(m=e.block[s])==null?void 0:m.value,a=[];if(r){if(r.type==="image"){let _=((c=e.signed_urls)==null?void 0:c[r.id])||((u=(i=(l=r.properties)==null?void 0:l.source)==null?void 0:i[0])==null?void 0:u[0]);_.includes("file.notion.so")&&(_=(T=(f=(y=r.properties)==null?void 0:y.source)==null?void 0:f[0])==null?void 0:T[0]),_&&a.push({block:r,url:_})}if((b=r.format)!=null&&b.page_cover){let p=r.format.page_cover;a.push({block:r,url:p})}if((d=r.format)!=null&&d.bookmark_cover){let p=r.format.bookmark_cover;a.push({block:r,url:p})}if((x=r.format)!=null&&x.bookmark_icon){let p=r.format.bookmark_icon;a.push({block:r,url:p})}let k=B(r,e);k&&A(k)&&a.push({block:r,url:k})}return a}).filter(Boolean).map(({block:s,url:r})=>t(r,s)).filter(Boolean);return Array.from(new Set(n))};import X from"mem";import ee from"normalize-url";var te=X(e=>{if(!e)return"";try{if(e.startsWith("https://www.notion.so/image/")){let t=new URL(e),o=decodeURIComponent(t.pathname.substr(7)),n=te(o);t.pathname=`/image/${encodeURIComponent(n)}`,e=t.toString()}return ee(e,{stripProtocol:!0,stripWWW:!0,stripHash:!0,stripTextFragment:!0,removeQueryParameters:!0})}catch(t){return""}});function Xe(e,t){return{block:g(g({},e.block),t.block),collection:g(g({},e.collection),t.collection),collection_view:g(g({},e.collection_view),t.collection_view),notion_user:g(g({},e.notion_user),t.notion_user),collection_query:g(g({},e.collection_query),t.collection_query),signed_urls:g(g({},e.signed_urls),t.signed_urls),preview_images:g(g({},e.preview_images),t.preview_images)}}var F=(e,{month:t="short"}={})=>{let o=new Date(e);return`${o.toLocaleString("en-US",{month:t})} ${o.getUTCDate()}, ${o.getUTCFullYear()}`};var rt=e=>{let t=`${e.start_time||""} ${e.start_date} ${e.time_zone||""}`;return F(t)};function oe(e,t,{wordsPerMinute:o=275,imageReadTimeInSeconds:n=12}={}){let s=C(e,t),r=s.numWords/o,m=(s.numImages>10?s.numImages/2*(n+3)+(s.numImages-10)*3:s.numImages/2*(2*n+(1-s.numImages)))/60,c=r+m;return U(g({},s),{totalWordsReadTimeInMinutes:r,totalImageReadTimeInMinutes:m,totalReadTimeInMinutes:c})}function ct(e,t,o){let n=oe(e,t,o);return ne(n.totalReadTimeInMinutes)}function C(e,t){var n,s,r,a;let o={numWords:0,numImages:0};if(!e)return o;for(let m of e.content||[]){let c=(n=t.block[m])==null?void 0:n.value,l=!1;if(!!c){switch(c.type){case"quote":case"alias":case"header":case"sub_header":case"sub_sub_header":{let i=v(c,t);o.numWords+=E(i);break}case"callout":case"toggle":case"to_do":case"bulleted_list":case"numbered_list":case"text":{let i=v(c,t);o.numWords+=E(i),l=!0;break}case"embed":case"tweet":case"maps":case"pdf":case"figma":case"typeform":case"codepen":case"excalidraw":case"gist":case"video":case"drive":case"audio":case"file":case"image":o.numImages+=1;break;case"bookmark":o.numImages+=.25;break;case"code":o.numImages+=2;break;case"table":case"collection_view":o.numImages+=2;break;case"column":case"column_list":case"transclusion_container":l=!0;break;case"table_of_contents":{let i=e;if(!i)continue;let u=S(i,t);for(let y of u)o.numWords+=E(y.text);break}case"transclusion_reference":{let i=(r=(s=c==null?void 0:c.format)==null?void 0:s.transclusion_reference_pointer)==null?void 0:r.id;if(!i)continue;let u=(a=t.block[i])==null?void 0:a.value;u&&j(o,C(u,t));break}default:break}l&&j(o,C(c,t))}}return o}function j(e,t){e.numWords+=t.numWords,e.numImages+=t.numImages}function E(e){return e?(e.match(/\w+/g)||[]).length:0}function ne(e){return e<.5?"less than a minute":e<1.5?"1 minute":`${Math.ceil(e)} minutes`}export{oe as estimatePageReadTime,ct as estimatePageReadTimeAsHumanizedString,F as formatDate,rt as formatNotionDateTime,Ee as getAllPagesInSpace,w as getBlockCollectionId,B as getBlockIcon,O as getBlockParentPage,v as getBlockTitle,We as getCanonicalPageId,Y as getDateValue,je as getPageBreadcrumbs,Te as getPageContentBlockIds,Ye as getPageImageUrls,P as getPageProperty,S as getPageTableOfContents,pe as getPageTitle,h as getTextContent,L as idToUuid,A as isUrl,Xe as mergeRecordMaps,z as normalizeTitle,te as normalizeUrl,W as parsePageId,M as uuidToId};
+var q=Object.defineProperty,N=Object.defineProperties;var V=Object.getOwnPropertyDescriptors;var $=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,Q=Object.prototype.propertyIsEnumerable;var D=(e,t,o)=>t in e?q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,g=(e,t)=>{for(var o in t||(t={}))H.call(t,o)&&D(e,o,t[o]);if($)for(var o of $(t))Q.call(t,o)&&D(e,o,t[o]);return e},U=(e,t)=>N(e,V(t));var I=(e,t,o)=>new Promise((r,s)=>{var n=c=>{try{m(o.next(c))}catch(l){s(l)}},i=c=>{try{m(o.throw(c))}catch(l){s(l)}},m=c=>c.done?r(c.value):Promise.resolve(c.value).then(n,i);m((o=o.apply(e,t)).next())});var h=e=>{var t;return e?Array.isArray(e)?(t=e==null?void 0:e.reduce((o,r)=>o+(r[0]!=="\u204D"&&r[0]!=="\u2023"?r[0]:""),""))!=null?t:"":e:""};function w(e,t){var s,n,i,m,c,l,a;let o=e.collection_id||((n=(s=e.format)==null?void 0:s.collection_pointer)==null?void 0:n.id);if(o)return o;let r=(i=e==null?void 0:e.view_ids)==null?void 0:i[0];if(r){let u=(c=(m=t.collection_view)==null?void 0:m[r])==null?void 0:c.value;if(u)return(a=(l=u.format)==null?void 0:l.collection_pointer)==null?void 0:a.id}return null}function v(e,t){var o,r;if((o=e.properties)!=null&&o.title)return h(e.properties.title);if(e.type==="collection_view_page"||e.type==="collection_view"){let s=w(e,t);if(s){let n=(r=t.collection[s])==null?void 0:r.value;if(n)return h(n.name)}}return""}function B(e,t){var o,r,s;if((o=e.format)!=null&&o.page_icon)return(r=e.format)==null?void 0:r.page_icon;if(e.type==="collection_view_page"||e.type==="collection_view"){let n=w(e,t);if(n){let i=(s=t.collection[n])==null?void 0:s.value;if(i)return i.icon}}return null}function pe(e){var o;let t=(o=e.block[Object.keys(e.block)[0]])==null?void 0:o.value;return t?v(t,e):null}function P(e,t,o){var r;try{if(!t.properties||!Object.keys(o.collection))return null;let s=(r=o.collection[t.parent_id])==null?void 0:r.value;if(s){let n=e.toLowerCase(),i=Object.keys(s.schema).find(l=>{var a,u;return((u=(a=s.schema[l])==null?void 0:a.name)==null?void 0:u.toLowerCase())===n});if(!i)return null;let{type:m}=s.schema[i],c=h(t.properties[i]);switch(m){case"created_time":return t.created_time;case"multi_select":return c.split(",");case"date":{let a=t.properties[i][0][1][0][1];if(a.type=="datetime")return new Date(`${a.start_date} ${a.start_time}`).getTime();if(a.type=="date")return new Date(a.start_date).getTime();if(a.type=="datetimerange"){let{start_date:u,start_time:y,end_date:f,end_time:T}=a,b=new Date(`${u} ${y}`).getTime(),d=new Date(`${f} ${T}`).getTime();return[b,d]}else{let u=new Date(a.start_date).getTime(),y=new Date(a.end_date).getTime();return[u,y]}}case"checkbox":return c=="Yes";case"last_edited_time":return t.last_edited_time;default:return c}}}catch(s){}return null}var Y=e=>{if(e&&Array.isArray(e)){if(e[0]==="d")return e[1];for(let t of e){let o=Y(t);if(o)return o}}return null};var O=(e,t,{inclusive:o=!1}={})=>{var s,n;let r=e;for(;r!=null;){if(o&&(r==null?void 0:r.type)==="page")return r;let i=r.parent_id,m=r.parent_table;if(!i)break;if(m==="collection")r=(s=t.collection[i])==null?void 0:s.value;else if(r=(n=t.block[i])==null?void 0:n.value,(r==null?void 0:r.type)==="page")return r}return null};var Z={header:0,sub_header:1,sub_sub_header:2},S=(e,t)=>{function o(n){return(n!=null?n:[]).map(i=>{var c,l;let m=(c=t.block[i])==null?void 0:c.value;if(m){let{type:a}=m;if(a==="header"||a==="sub_header"||a==="sub_sub_header")return{id:i,type:a,text:h((l=m.properties)==null?void 0:l.title),indentLevel:Z[a]};if(a==="transclusion_container")return o(m.content)}return null})}let r=o(e.content).flat().filter(Boolean),s=[{actual:-1,effective:-1}];for(let n of r){let{indentLevel:i}=n,m=i;do{let c=s[s.length-1],{actual:l,effective:a}=c;if(m>l)n.indentLevel=a+1,s.push({actual:m,effective:n.indentLevel});else if(m===l){n.indentLevel=a;break}else s.pop()}while(!0)}return r};var Te=(e,t)=>{let o=t||Object.keys(e.block)[0],r=new Set;function s(n){var u,y,f,T;if(r.has(n))return;r.add(n);let i=(u=e.block[n])==null?void 0:u.value;if(!i)return;let{content:m,type:c,properties:l,format:a}=i;if(l)for(let b of Object.keys(l)){let d=l[b];d.map(_=>{var k,R;let p=(R=(k=_==null?void 0:_[0])==null?void 0:k[1])==null?void 0:R[0];(p==null?void 0:p[0])==="p"&&p[1]&&s(p[1])});let x=(f=(y=d==null?void 0:d[0])==null?void 0:y[1])==null?void 0:f[0];(x==null?void 0:x[0])==="p"&&x[1]&&s(x[1])}if(a){let b=(T=a.transclusion_reference_pointer)==null?void 0:T.id;b&&s(b)}if(!(!m||!Array.isArray(m))&&!(n!==o&&(c==="page"||c==="collection_view_page")))for(let b of m)s(b)}return s(o),Array.from(r)};var L=(e="")=>`${e.substr(0,8)}-${e.substr(8,4)}-${e.substr(12,4)}-${e.substr(16,4)}-${e.substr(20)}`;var G=/\b([a-f0-9]{32})\b/,J=/\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\b/,M=(e="",{uuid:t=!0}={})=>{if(!e)return null;e=e.split("?")[0];let o=e.match(G);if(o)return t?L(o[1]):o[1];let r=e.match(J);return r?t?r[1]:r[1].replace(/-/g,""):null};var W=e=>e.replace(/-/g,"");import K from"p-queue";function Ee(i,m,c){return I(this,arguments,function*(e,t,o,{concurrency:r=4,traverseCollections:s=!0,targetPageId:n=null}={}){let l={},a=new Set,u=new K({concurrency:r});function y(f){return I(this,null,function*(){n&&a.has(n)||(f=M(f),f&&!l[f]&&!a.has(f)&&(a.add(f),u.add(()=>I(this,null,function*(){var T,b;try{if(n&&a.has(n)&&f!==n)return;let d=yield o(f);if(!d)return;let x=(b=(T=d.block[f])==null?void 0:T.value)==null?void 0:b.space_id;if(x){if(!t)t=x;else if(t!==x)return}if(Object.keys(d.block).filter(_=>{var k;let p=(k=d.block[_])==null?void 0:k.value;return!(!p||p.type!=="page"&&p.type!=="collection_view_page"||t&&p.space_id&&p.space_id!==t)}).forEach(_=>y(_)),s)for(let _ of Object.values(d.collection_query))for(let p of Object.values(_)){let{blockIds:k}=p;if(k)for(let R of k)y(R)}l[f]=d}catch(d){console.warn("page load error",{pageId:f,spaceId:t},d.statusCode,d.message),l[f]=null}a.delete(f)}))))})}return yield y(e),yield u.onIdle(),l})}var z=e=>(e||"").replace(/ /g,"-").replace(/[^a-zA-Z0-9-\u4e00-\u9FFF\u3041-\u3096\u30A1-\u30FC\u3000-\u303F]/g,"").replace(/--/g,"-").replace(/-$/,"").replace(/^-/,"").trim().toLowerCase();var Me=(e,t,{uuid:o=!0}={})=>{var n;if(!e||!t)return null;let r=W(e),s=(n=t.block[e])==null?void 0:n.value;if(s){let i=P("slug",s,t)||P("Slug",s,t)||z(v(s,t));if(i)return o?`${i}-${r}`:i}return r};var je=(e,t)=>{var n;let o=e.block,r=[],s=t;do{let i=(n=o[s])==null?void 0:n.value;if(!i)break;let m=v(i,e),c=B(i,e);if(!(m||c))break;r.push({block:i,active:s===t,pageId:s,title:m,icon:c});let l=O(i,e),a=l==null?void 0:l.id;if(!a)break;s=a}while(!0);return r.reverse(),r};import A from"is-url-superb";var Ye=(e,{mapImageUrl:t})=>{let r=Object.keys(e.block).flatMap(s=>{var m,c,l,a,u,y,f,T,b,d,x;let n=(m=e.block[s])==null?void 0:m.value,i=[];if(n){if(n.type==="image"){let k=((c=e.signed_urls)==null?void 0:c[n.id])||((u=(a=(l=n.properties)==null?void 0:l.source)==null?void 0:a[0])==null?void 0:u[0]);k.includes("file.notion.so")&&(k=(T=(f=(y=n.properties)==null?void 0:y.source)==null?void 0:f[0])==null?void 0:T[0]),k&&i.push({block:n,url:k})}if((b=n.format)!=null&&b.page_cover){let p=n.format.page_cover;i.push({block:n,url:p})}if((d=n.format)!=null&&d.bookmark_cover){let p=n.format.bookmark_cover;i.push({block:n,url:p})}if((x=n.format)!=null&&x.bookmark_icon){let p=n.format.bookmark_icon;i.push({block:n,url:p})}let _=B(n,e);_&&A(_)&&i.push({block:n,url:_})}return i}).filter(Boolean).map(({block:s,url:n})=>t(n,s)).filter(Boolean);return Array.from(new Set(r))};import X from"mem";import ee from"normalize-url";var te=X(e=>{if(!e)return"";try{if(e.startsWith("https://www.notion.so/image/")){let t=new URL(e),o=decodeURIComponent(t.pathname.substr(7)),r=te(o);t.pathname=`/image/${encodeURIComponent(r)}`,e=t.toString()}return ee(e,{stripProtocol:!0,stripWWW:!0,stripHash:!0,stripTextFragment:!0,removeQueryParameters:!0})}catch(t){return""}});function Xe(e,t){return{block:g(g({},e.block),t.block),collection:g(g({},e.collection),t.collection),collection_view:g(g({},e.collection_view),t.collection_view),notion_user:g(g({},e.notion_user),t.notion_user),collection_query:g(g({},e.collection_query),t.collection_query),signed_urls:g(g({},e.signed_urls),t.signed_urls),preview_images:g(g({},e.preview_images),t.preview_images)}}var F=(e,{month:t="short"}={})=>{let o=new Date(e);return`${o.toLocaleString("en-US",{month:t})} ${o.getUTCDate()}, ${o.getUTCFullYear()}`};var rt=e=>{let t=`${e.start_time||""} ${e.start_date} ${e.time_zone||""}`;return F(t)};function oe(e,t,{wordsPerMinute:o=275,imageReadTimeInSeconds:r=12}={}){let s=C(e,t),n=s.numWords/o,m=(s.numImages>10?s.numImages/2*(r+3)+(s.numImages-10)*3:s.numImages/2*(2*r+(1-s.numImages)))/60,c=n+m;return U(g({},s),{totalWordsReadTimeInMinutes:n,totalImageReadTimeInMinutes:m,totalReadTimeInMinutes:c})}function ct(e,t,o){let r=oe(e,t,o);return ne(r.totalReadTimeInMinutes)}function C(e,t){var r,s,n,i;let o={numWords:0,numImages:0};if(!e)return o;for(let m of e.content||[]){let c=(r=t.block[m])==null?void 0:r.value,l=!1;if(!!c){switch(c.type){case"quote":case"alias":case"header":case"sub_header":case"sub_sub_header":{let a=v(c,t);o.numWords+=E(a);break}case"callout":case"toggle":case"to_do":case"bulleted_list":case"numbered_list":case"text":{let a=v(c,t);o.numWords+=E(a),l=!0;break}case"embed":case"tweet":case"maps":case"pdf":case"figma":case"typeform":case"codepen":case"excalidraw":case"gist":case"video":case"drive":case"audio":case"file":case"image":o.numImages+=1;break;case"bookmark":o.numImages+=.25;break;case"code":o.numImages+=2;break;case"table":case"collection_view":o.numImages+=2;break;case"column":case"column_list":case"transclusion_container":l=!0;break;case"table_of_contents":{let a=e;if(!a)continue;let u=S(a,t);for(let y of u)o.numWords+=E(y.text);break}case"transclusion_reference":{let a=(n=(s=c==null?void 0:c.format)==null?void 0:s.transclusion_reference_pointer)==null?void 0:n.id;if(!a)continue;let u=(i=t.block[a])==null?void 0:i.value;u&&j(o,C(u,t));break}default:break}l&&j(o,C(c,t))}}return o}function j(e,t){e.numWords+=t.numWords,e.numImages+=t.numImages}function E(e){return e?(e.match(/\w+/g)||[]).length:0}function ne(e){return e<.5?"less than a minute":e<1.5?"1 minute":`${Math.ceil(e)} minutes`}export{oe as estimatePageReadTime,ct as estimatePageReadTimeAsHumanizedString,F as formatDate,rt as formatNotionDateTime,Ee as getAllPagesInSpace,w as getBlockCollectionId,B as getBlockIcon,O as getBlockParentPage,v as getBlockTitle,Me as getCanonicalPageId,Y as getDateValue,je as getPageBreadcrumbs,Te as getPageContentBlockIds,Ye as getPageImageUrls,P as getPageProperty,S as getPageTableOfContents,pe as getPageTitle,h as getTextContent,L as idToUuid,A as isUrl,Xe as mergeRecordMaps,z as normalizeTitle,te as normalizeUrl,M as parsePageId,W as uuidToId};
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/build/index.js.map b/build/index.js.map
index db8d734076331384ae2ce9ca52b52504e81db643..395f30a4958ad8507b98889bae0c5f281bea0b83 100644
--- a/build/index.js.map
+++ b/build/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/get-text-content.ts","../src/get-block-collection-id.ts","../src/get-block-title.ts","../src/get-block-icon.ts","../src/get-page-title.ts","../src/get-page-property.ts","../src/get-date-value.ts","../src/get-block-parent-page.ts","../src/get-page-table-of-contents.ts","../src/get-page-content-block-ids.ts","../src/id-to-uuid.ts","../src/parse-page-id.ts","../src/uuid-to-id.ts","../src/get-all-pages-in-space.ts","../src/normalize-title.ts","../src/get-canonical-page-id.ts","../src/get-page-breadcrumbs.ts","../src/is-url.ts","../src/get-page-image-urls.ts","../src/normalize-url.ts","../src/merge-record-maps.ts","../src/format-date.ts","../src/format-notion-date-time.ts","../src/estimate-page-read-time.ts"],"sourcesContent":["import * as types from 'notion-types'\n\n/**\n * Gets the raw, unformatted text content of a block's content value.\n *\n * This is useful, for instance, for extracting a block's `title` without any\n * rich text formatting.\n */\nexport const getTextContent = (text?: types.Decoration[]): string => {\n  if (!text) {\n    return ''\n  } else if (Array.isArray(text)) {\n    return (\n      text?.reduce(\n        (prev, current) =>\n          prev + (current[0] !== '⁍' && current[0] !== '‣' ? current[0] : ''),\n        ''\n      ) ?? ''\n    )\n  } else {\n    return text\n  }\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\n\nexport function getBlockCollectionId(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): string | null {\n  const collectionId =\n    (block as any).collection_id ||\n    (block as any).format?.collection_pointer?.id\n\n  if (collectionId) {\n    return collectionId\n  }\n\n  const collectionViewId = (block as any)?.view_ids?.[0]\n  if (collectionViewId) {\n    const collectionView = recordMap.collection_view?.[collectionViewId]?.value\n    if (collectionView) {\n      const collectionId = collectionView.format?.collection_pointer?.id\n      return collectionId\n    }\n  }\n\n  return null\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockCollectionId } from './get-block-collection-id'\nimport { getTextContent } from './get-text-content'\n\nexport function getBlockTitle(block: Block, recordMap: ExtendedRecordMap) {\n  if (block.properties?.title) {\n    return getTextContent(block.properties.title)\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return getTextContent(collection.name)\n      }\n    }\n  }\n\n  return ''\n}\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\n\nimport { getBlockCollectionId } from './get-block-collection-id'\n\nexport function getBlockIcon(block: Block, recordMap: ExtendedRecordMap) {\n  if ((block as PageBlock).format?.page_icon) {\n    return (block as PageBlock).format?.page_icon\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return collection.icon\n      }\n    }\n  }\n\n  return null\n}\n","import { ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\n\nexport function getPageTitle(recordMap: ExtendedRecordMap) {\n  const pageBlock = recordMap.block[Object.keys(recordMap.block)[0]]?.value\n\n  if (pageBlock) {\n    return getBlockTitle(pageBlock, recordMap)\n  }\n\n  return null\n}\n","import { Block, DateFormat, ExtendedRecordMap } from 'notion-types'\n\nimport { getTextContent } from './get-text-content'\n\n/**\n * Gets the value of a collection property for a given page (collection item).\n *\n * @param propertyName property name\n * @param block Page block, often be first block in blockMap\n * @param recordMap\n * @returns - The return value types will follow the following principles:\n *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)\n *  2. property is text-like will return `string`\n *  3. multi select property will return `string[]`\n *  4. checkbox property return `boolean`\n * @todo complete all no-text property type\n */\nexport function getPageProperty<\n  T = string | number | boolean | string[] | number[]\n>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T\nexport function getPageProperty(\n  propertyName: string,\n  block: Block,\n  recordMap: ExtendedRecordMap\n) {\n  try {\n    if (!block.properties || !Object.keys(recordMap.collection)) {\n      // console.warn(\n      //   `block ${block.id} has no properties or this recordMap has no collection record`\n      // )\n      return null\n    }\n\n    const collection = recordMap.collection[block.parent_id]?.value\n\n    if (collection) {\n      const propertyNameL = propertyName.toLowerCase()\n      const propertyId = Object.keys(collection.schema).find(\n        (key) => collection.schema[key]?.name?.toLowerCase() === propertyNameL\n      )\n\n      if (!propertyId) {\n        return null\n      }\n\n      const { type } = collection.schema[propertyId]\n      const content = getTextContent(block.properties[propertyId])\n\n      switch (type) {\n        case 'created_time':\n          return block.created_time\n\n        case 'multi_select':\n          return content.split(',')\n\n        case 'date': {\n          const property = block.properties[propertyId] as [['‣', [DateFormat]]]\n          const formatDate = property[0][1][0][1]\n\n          if (formatDate.type == 'datetime') {\n            return new Date(\n              `${formatDate.start_date} ${formatDate.start_time}`\n            ).getTime()\n          } else if (formatDate.type == 'date') {\n            return new Date(formatDate.start_date).getTime()\n          } else if (formatDate.type == 'datetimerange') {\n            const { start_date, start_time, end_date, end_time } = formatDate\n            const startTime = new Date(`${start_date} ${start_time}`).getTime()\n            const endTime = new Date(`${end_date} ${end_time}`).getTime()\n            return [startTime, endTime]\n          } else {\n            const startTime = new Date(formatDate.start_date).getTime()\n            const endTime = new Date(formatDate.end_date).getTime()\n            return [startTime, endTime]\n          }\n        }\n\n        case 'checkbox':\n          return content == 'Yes'\n\n        case 'last_edited_time':\n          return block.last_edited_time\n\n        default:\n          return content\n      }\n    }\n  } catch {\n    // ensure that no matter what, we don't throw errors because of an unexpected\n    // collection data format\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Attempts to find a valid date from a given property.\n */\nexport const getDateValue = (prop: any[]): types.FormattedDate | null => {\n  if (prop && Array.isArray(prop)) {\n    if (prop[0] === 'd') {\n      return prop[1]\n    } else {\n      for (const v of prop) {\n        const value = getDateValue(v)\n        if (value) {\n          return value\n        }\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Returns the parent page block containing a given page.\n *\n * Note that many times this will not be the direct parent block since\n * some non-page content blocks can contain sub-blocks.\n */\nexport const getBlockParentPage = (\n  block: types.Block,\n  recordMap: types.ExtendedRecordMap,\n  {\n    inclusive = false\n  }: {\n    inclusive?: boolean\n  } = {}\n): types.PageBlock | null => {\n  let currentRecord: types.Block | types.Collection = block\n\n  while (currentRecord != null) {\n    if (inclusive && (currentRecord as types.Block)?.type === 'page') {\n      return currentRecord as types.PageBlock\n    }\n\n    const parentId: string = currentRecord.parent_id\n    const parentTable = currentRecord.parent_table\n\n    if (!parentId) {\n      break\n    }\n\n    if (parentTable === 'collection') {\n      currentRecord = recordMap.collection[parentId]?.value\n    } else {\n      currentRecord = recordMap.block[parentId]?.value\n\n      if ((currentRecord as types.Block)?.type === 'page') {\n        return currentRecord as types.PageBlock\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\nimport { getTextContent } from './get-text-content'\n\nexport interface TableOfContentsEntry {\n  id: types.ID\n  type: types.BlockType\n  text: string\n  indentLevel: number\n}\n\nconst indentLevels = {\n  header: 0,\n  sub_header: 1,\n  sub_sub_header: 2\n}\n\n/**\n * Gets the metadata for a table of contents block by parsing the page's\n * H1, H2, and H3 elements.\n */\nexport const getPageTableOfContents = (\n  page: types.PageBlock,\n  recordMap: types.ExtendedRecordMap\n): Array<TableOfContentsEntry> => {\n  const toc = (page.content ?? [])\n    .map((blockId: string) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (block) {\n        const { type } = block\n\n        if (\n          type === 'header' ||\n          type === 'sub_header' ||\n          type === 'sub_sub_header'\n        ) {\n          return {\n            id: blockId,\n            type,\n            text: getTextContent(block.properties?.title),\n            indentLevel: indentLevels[type]\n          }\n        }\n      }\n\n      return null\n    })\n    .filter(Boolean) as Array<TableOfContentsEntry>\n\n  const indentLevelStack = [\n    {\n      actual: -1,\n      effective: -1\n    }\n  ]\n\n  // Adjust indent levels to always change smoothly.\n  // This is a little tricky, but the key is that when increasing indent levels,\n  // they should never jump more than one at a time.\n  for (const tocItem of toc) {\n    const { indentLevel } = tocItem\n    const actual = indentLevel\n\n    do {\n      const prevIndent = indentLevelStack[indentLevelStack.length - 1]\n      const { actual: prevActual, effective: prevEffective } = prevIndent\n\n      if (actual > prevActual) {\n        tocItem.indentLevel = prevEffective + 1\n        indentLevelStack.push({\n          actual,\n          effective: tocItem.indentLevel\n        })\n      } else if (actual === prevActual) {\n        tocItem.indentLevel = prevEffective\n        break\n      } else {\n        indentLevelStack.pop()\n      }\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true)\n  }\n\n  return toc\n}\n","import * as types from 'notion-types'\n\n/**\n * Gets the IDs of all blocks contained on a page starting from a root block ID.\n */\nexport const getPageContentBlockIds = (\n  recordMap: types.ExtendedRecordMap,\n  blockId?: string\n): string[] => {\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0]\n  const contentBlockIds = new Set<string>()\n\n  function addContentBlocks(blockId: string) {\n    if (contentBlockIds.has(blockId)) return\n    contentBlockIds.add(blockId)\n\n    const block = recordMap.block[blockId]?.value\n    if (!block) return\n\n    const { content, type, properties, format } = block\n    if (properties) {\n      // TODO: this needs some love, especially for resolving relation properties\n      // see this collection_view_page for an example: 8a586d253f984b85b48254da84465d23\n      for (const key of Object.keys(properties)) {\n        const p = properties[key]\n        p.map((d: any) => {\n          const value = d?.[0]?.[1]?.[0]\n          if (value?.[0] === 'p' && value[1]) {\n            addContentBlocks(value[1])\n          }\n        })\n\n        // [[\"‣\", [[\"p\", \"841918aa-f2a3-4d4c-b5ad-64b0f57c47b8\"]]]]\n        const value = p?.[0]?.[1]?.[0]\n\n        if (value?.[0] === 'p' && value[1]) {\n          addContentBlocks(value[1])\n        }\n      }\n    }\n\n    if (format) {\n      const referenceId = format.transclusion_reference_pointer?.id\n      if (referenceId) {\n        addContentBlocks(referenceId)\n      }\n    }\n\n    if (!content || !Array.isArray(content)) {\n      // no child content blocks to recurse on\n      return\n    }\n\n    if (blockId !== rootBlockId) {\n      if (type === 'page' || type === 'collection_view_page') {\n        // ignore the content of other pages and collections\n        return\n      }\n    }\n\n    for (const blockId of content) {\n      addContentBlocks(blockId)\n    }\n  }\n\n  addContentBlocks(rootBlockId)\n  return Array.from(contentBlockIds)\n}\n","export const idToUuid = (id = '') =>\n  `${id.substr(0, 8)}-${id.substr(8, 4)}-${id.substr(12, 4)}-${id.substr(\n    16,\n    4\n  )}-${id.substr(20)}`\n","import { idToUuid } from './id-to-uuid'\n\nconst pageIdRe = /\\b([a-f0-9]{32})\\b/\nconst pageId2Re =\n  /\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/\n\n/**\n * Robustly extracts the notion page ID from a notion URL or pathname suffix.\n *\n * Defaults to returning a UUID (with dashes).\n */\nexport const parsePageId = (\n  id: string | null = '',\n  { uuid = true }: { uuid?: boolean } = {}\n) => {\n  if (!id) {\n    return null\n  }\n\n  id = id.split('?')[0]\n  const match = id.match(pageIdRe)\n\n  if (match) {\n    return uuid ? idToUuid(match[1]) : match[1]\n  }\n\n  const match2 = id.match(pageId2Re)\n  if (match2) {\n    return uuid ? match2[1] : match2[1].replace(/-/g, '')\n  }\n\n  return null\n}\n","export const uuidToId = (uuid: string) => uuid.replace(/-/g, '')\n","import { ExtendedRecordMap, PageMap } from 'notion-types'\nimport PQueue from 'p-queue'\n\nimport { parsePageId } from './parse-page-id'\n\n/**\n * Performs a traversal over a given Notion workspace starting from a seed page.\n *\n * Returns a map containing all of the pages that are reachable from the seed\n * page in the space.\n *\n * If `rootSpaceId` is not defined, the space ID of the root page will be used\n * to scope traversal.\n *\n *\n * @param rootPageId - Page ID to start from.\n * @param rootSpaceId - Space ID to scope traversal.\n * @param getPage - Function used to fetch a single page.\n * @param opts - Optional config\n */\nexport async function getAllPagesInSpace(\n  rootPageId: string,\n  rootSpaceId: string | undefined,\n  getPage: (pageId: string) => Promise<ExtendedRecordMap>,\n  {\n    concurrency = 4,\n    traverseCollections = true,\n    targetPageId = null\n  }: {\n    concurrency?: number\n    traverseCollections?: boolean\n    targetPageId?: string\n  } = {}\n): Promise<PageMap> {\n  const pages: PageMap = {}\n  const pendingPageIds = new Set<string>()\n  const queue = new PQueue({ concurrency })\n\n  async function processPage(pageId: string) {\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\n      return\n    }\n\n    pageId = parsePageId(pageId) as string\n\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\n      pendingPageIds.add(pageId)\n\n      queue.add(async () => {\n        try {\n          if (\n            targetPageId &&\n            pendingPageIds.has(targetPageId) &&\n            pageId !== targetPageId\n          ) {\n            return\n          }\n\n          const page = await getPage(pageId)\n          if (!page) {\n            return\n          }\n\n          const spaceId = page.block[pageId]?.value?.space_id\n\n          if (spaceId) {\n            if (!rootSpaceId) {\n              rootSpaceId = spaceId\n            } else if (rootSpaceId !== spaceId) {\n              return\n            }\n          }\n\n          Object.keys(page.block)\n            .filter((key) => {\n              const block = page.block[key]?.value\n              if (!block) return false\n\n              if (\n                block.type !== 'page' &&\n                block.type !== 'collection_view_page'\n              ) {\n                return false\n              }\n\n              // the space id check is important to limit traversal because pages\n              // can reference pages in other spaces\n              if (\n                rootSpaceId &&\n                block.space_id &&\n                block.space_id !== rootSpaceId\n              ) {\n                return false\n              }\n\n              return true\n            })\n            .forEach((subPageId) => processPage(subPageId))\n\n          // traverse collection item pages as they may contain subpages as well\n          if (traverseCollections) {\n            for (const collectionViews of Object.values(\n              page.collection_query\n            )) {\n              for (const collectionData of Object.values(collectionViews)) {\n                const { blockIds } = collectionData\n\n                if (blockIds) {\n                  for (const collectionItemId of blockIds) {\n                    processPage(collectionItemId)\n                  }\n                }\n              }\n            }\n          }\n\n          pages[pageId] = page\n        } catch (err) {\n          console.warn(\n            'page load error',\n            { pageId, spaceId: rootSpaceId },\n            err.statusCode,\n            err.message\n          )\n          pages[pageId] = null\n        }\n\n        pendingPageIds.delete(pageId)\n      })\n    }\n  }\n\n  await processPage(rootPageId)\n  await queue.onIdle()\n\n  return pages\n}\n","export const normalizeTitle = (title?: string | null): string => {\n  return (title || '')\n    .replace(/ /g, '-')\n    .replace(\n      /[^a-zA-Z0-9-\\u4e00-\\u9FFF\\u3041-\\u3096\\u30A1-\\u30FC\\u3000-\\u303F]/g,\n      ''\n    )\n    .replace(/--/g, '-')\n    .replace(/-$/, '')\n    .replace(/^-/, '')\n    .trim()\n    .toLowerCase()\n}\n","import { ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\nimport { getPageProperty } from './get-page-property'\nimport { normalizeTitle } from './normalize-title'\nimport { uuidToId } from './uuid-to-id'\n\n/**\n * Gets the canonical, display-friendly version of a page's ID for use in URLs.\n */\nexport const getCanonicalPageId = (\n  pageId: string,\n  recordMap: ExtendedRecordMap,\n  { uuid = true }: { uuid?: boolean } = {}\n): string | null => {\n  if (!pageId || !recordMap) return null\n\n  const id = uuidToId(pageId)\n  const block = recordMap.block[pageId]?.value\n\n  if (block) {\n    const slug =\n      (getPageProperty('slug', block, recordMap) as string | null) ||\n      (getPageProperty('Slug', block, recordMap) as string | null) ||\n      normalizeTitle(getBlockTitle(block, recordMap))\n\n    if (slug) {\n      if (uuid) {\n        return `${slug}-${id}`\n      } else {\n        return slug\n      }\n    }\n  }\n\n  return id\n}\n","import * as types from 'notion-types'\n\nimport { getBlockIcon } from './get-block-icon'\nimport { getBlockParentPage } from './get-block-parent-page'\nimport { getBlockTitle } from './get-block-title'\n\nexport const getPageBreadcrumbs = (\n  recordMap: types.ExtendedRecordMap,\n  activePageId: string\n): Array<any> | null => {\n  const blockMap = recordMap.block\n  const breadcrumbs = []\n\n  let currentPageId = activePageId\n\n  do {\n    const block = blockMap[currentPageId]?.value\n    if (!block) {\n      break\n    }\n\n    const title = getBlockTitle(block, recordMap)\n    const icon = getBlockIcon(block, recordMap)\n\n    if (!(title || icon)) {\n      break\n    }\n\n    breadcrumbs.push({\n      block,\n      active: currentPageId === activePageId,\n      pageId: currentPageId,\n      title,\n      icon\n    })\n\n    const parentBlock = getBlockParentPage(block, recordMap)\n    const parentId = parentBlock?.id\n\n    if (!parentId) {\n      break\n    }\n\n    currentPageId = parentId\n\n    // eslint-disable-next-line no-constant-condition\n  } while (true)\n\n  breadcrumbs.reverse()\n\n  return breadcrumbs\n}\n","import isUrl from 'is-url-superb'\n\nexport { isUrl }\n","import * as types from 'notion-types'\n\nimport { getBlockIcon } from './get-block-icon'\nimport { isUrl } from './is-url'\n\n/**\n * Gets URLs of all images contained on the given page.\n */\nexport const getPageImageUrls = (\n  recordMap: types.ExtendedRecordMap,\n  {\n    mapImageUrl\n  }: {\n    mapImageUrl: (url: string, block: types.Block) => string | null\n  }\n): string[] => {\n  const blockIds = Object.keys(recordMap.block)\n  const imageUrls: string[] = blockIds\n    .flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n      const images: Array<{ block: types.Block; url: string }> = []\n\n      if (block) {\n        if (block.type === 'image') {\n          const signedUrl = recordMap.signed_urls?.[block.id]\n          let source = signedUrl || block.properties?.source?.[0]?.[0]\n          if (source.includes('file.notion.so')) {\n            source = block.properties?.source?.[0]?.[0]\n          }\n\n          if (source) {\n            images.push({\n              block,\n              url: source\n            })\n          }\n        }\n\n        if ((block.format as any)?.page_cover) {\n          const source = (block.format as any).page_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_cover) {\n          const source = (block.format as any).bookmark_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_icon) {\n          const source = (block.format as any).bookmark_icon\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        const pageIcon = getBlockIcon(block, recordMap)\n        if (pageIcon && isUrl(pageIcon)) {\n          images.push({\n            block,\n            url: pageIcon\n          })\n        }\n      }\n\n      return images\n    })\n    .filter(Boolean)\n    .map(({ block, url }) => mapImageUrl(url, block))\n    .filter(Boolean)\n\n  return Array.from(new Set(imageUrls))\n}\n","import mem from 'mem'\nimport normalizeUrlImpl from 'normalize-url'\n\nexport const normalizeUrl = mem((url?: string) => {\n  if (!url) {\n    return ''\n  }\n\n  try {\n    if (url.startsWith('https://www.notion.so/image/')) {\n      const u = new URL(url)\n      const subUrl = decodeURIComponent(u.pathname.substr('/image/'.length))\n      const normalizedSubUrl = normalizeUrl(subUrl)\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`\n      url = u.toString()\n    }\n\n    return normalizeUrlImpl(url, {\n      stripProtocol: true,\n      stripWWW: true,\n      stripHash: true,\n      stripTextFragment: true,\n      removeQueryParameters: true\n    })\n  } catch (err) {\n    return ''\n  }\n})\n","import { ExtendedRecordMap } from 'notion-types'\n\nexport function mergeRecordMaps(\n  recordMapA: ExtendedRecordMap,\n  recordMapB: ExtendedRecordMap\n): ExtendedRecordMap {\n  const mergedRecordMap: ExtendedRecordMap = {\n    block: {\n      ...recordMapA.block,\n      ...recordMapB.block\n    },\n    collection: {\n      ...recordMapA.collection,\n      ...recordMapB.collection\n    },\n    collection_view: {\n      ...recordMapA.collection_view,\n      ...recordMapB.collection_view\n    },\n    notion_user: {\n      ...recordMapA.notion_user,\n      ...recordMapB.notion_user\n    },\n    collection_query: {\n      ...recordMapA.collection_query,\n      ...recordMapB.collection_query\n    },\n    signed_urls: {\n      ...recordMapA.signed_urls,\n      ...recordMapB.signed_urls\n    },\n    preview_images: {\n      ...recordMapA.preview_images,\n      ...recordMapB.preview_images\n    }\n  }\n\n  return mergedRecordMap\n}\n","export const formatDate = (\n  input: string | number,\n  { month = 'short' }: { month?: 'long' | 'short' } = {}\n) => {\n  const date = new Date(input)\n  const monthLocale = date.toLocaleString('en-US', { month })\n  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`\n}\n","import { formatDate } from './format-date'\n\nexport interface NotionDateTime {\n  type: 'datetime'\n  start_date: string\n  start_time?: string\n  time_zone?: string\n}\n\nexport const formatNotionDateTime = (datetime: NotionDateTime) => {\n  const dateString = `${datetime.start_time || ''} ${datetime.start_date} ${\n    datetime.time_zone || ''\n  }`\n  return formatDate(dateString)\n}\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\nimport { getPageTableOfContents } from './get-page-table-of-contents'\n\ntype EstimatePageReadTimeOptions = {\n  wordsPerMinute?: number\n  imageReadTimeInSeconds?: number\n}\n\ntype ContentStats = {\n  numWords: number\n  numImages: number\n}\n\ntype PageReadTimeEstimate = ContentStats & {\n  totalWordsReadTimeInMinutes: number\n  totalImageReadTimeInMinutes: number\n  totalReadTimeInMinutes: number\n}\n\n/**\n * Returns an estimate for the time it would take for a person to read the content\n * in the given Notion page.\n *\n * Uses Medium for inspiration.\n *\n * @see https://blog.medium.com/read-time-and-you-bc2048ab620c\n * @see https://github.com/ngryman/reading-time\n *\n * TODO: handle non-english content.\n */\nexport function estimatePageReadTime(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  {\n    wordsPerMinute = 275,\n    imageReadTimeInSeconds = 12\n  }: EstimatePageReadTimeOptions = {}\n): PageReadTimeEstimate {\n  const stats = getBlockContentStats(block, recordMap)\n  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute\n  const totalImageReadTimeInSeconds =\n    stats.numImages > 10\n      ? (stats.numImages / 2) * (imageReadTimeInSeconds + 3) +\n        (stats.numImages - 10) * 3 // n/2(a+b) + 3 sec/image\n      : (stats.numImages / 2) *\n        (2 * imageReadTimeInSeconds + (1 - stats.numImages)) // n/2[2a+(n-1)d]\n  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60\n\n  const totalReadTimeInMinutes =\n    totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes\n\n  return {\n    ...stats,\n    totalWordsReadTimeInMinutes,\n    totalImageReadTimeInMinutes,\n    totalReadTimeInMinutes\n  }\n}\n\n/**\n * Same as `estimatePageReadTime`, except it returns the total time estimate as\n * a human-readable string.\n *\n * For example, \"9 minutes\" or \"less than a minute\".\n */\nexport function estimatePageReadTimeAsHumanizedString(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  opts: EstimatePageReadTimeOptions\n) {\n  const estimate = estimatePageReadTime(block, recordMap, opts)\n  return humanizeReadTime(estimate.totalReadTimeInMinutes)\n}\n\nfunction getBlockContentStats(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): ContentStats {\n  const stats: ContentStats = {\n    numWords: 0,\n    numImages: 0\n  }\n\n  if (!block) {\n    return stats\n  }\n\n  for (const childId of block.content || []) {\n    const child = recordMap.block[childId]?.value\n    let recurse = false\n    if (!child) continue\n\n    switch (child.type) {\n      case 'quote':\n      // fallthrough\n      case 'alias':\n      // fallthrough\n      case 'header':\n      // fallthrough\n      case 'sub_header':\n      // fallthrough\n      case 'sub_sub_header': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        break\n      }\n\n      case 'callout':\n      // fallthrough\n      case 'toggle':\n      // fallthrough\n      case 'to_do':\n      // fallthrough\n      case 'bulleted_list':\n      // fallthrough\n      case 'numbered_list':\n      // fallthrough\n      case 'text': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        recurse = true\n        break\n      }\n\n      case 'embed':\n      // fallthrough\n      case 'tweet':\n      // fallthrough\n      case 'maps':\n      // fallthrough\n      case 'pdf':\n      // fallthrough\n      case 'figma':\n      // fallthrough\n      case 'typeform':\n      // fallthrough\n      case 'codepen':\n      // fallthrough\n      case 'excalidraw':\n      // fallthrough\n      case 'gist':\n      // fallthrough\n      case 'video':\n      // fallthrough\n      case 'drive':\n      // fallthrough\n      case 'audio':\n      // fallthrough\n      case 'file':\n      // fallthrough\n      case 'image':\n        // treat all embeds as images\n        stats.numImages += 1\n        break\n\n      case 'bookmark':\n        // treat bookmarks as quarter images since they aren't as content-ful as embedd images\n        stats.numImages += 0.25\n        break\n\n      case 'code':\n        // treat code blocks as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'table':\n      // fallthrough\n      case 'collection_view':\n        // treat collection views as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'column':\n      // fallthrough\n      case 'column_list':\n      // fallthrough\n      case 'transclusion_container':\n        recurse = true\n        break\n\n      case 'table_of_contents': {\n        const page = block as PageBlock\n        if (!page) continue\n\n        const toc = getPageTableOfContents(page, recordMap)\n        for (const tocItem of toc) {\n          stats.numWords += countWordsInText(tocItem.text)\n        }\n\n        break\n      }\n\n      case 'transclusion_reference': {\n        const referencePointerId =\n          child?.format?.transclusion_reference_pointer?.id\n\n        if (!referencePointerId) {\n          continue\n        }\n        const referenceBlock = recordMap.block[referencePointerId]?.value\n        if (referenceBlock) {\n          mergeContentStats(\n            stats,\n            getBlockContentStats(referenceBlock, recordMap)\n          )\n        }\n        break\n      }\n\n      default:\n        // ignore unrecognized blocks\n        break\n    }\n\n    if (recurse) {\n      mergeContentStats(stats, getBlockContentStats(child, recordMap))\n    }\n  }\n\n  return stats\n}\n\nfunction mergeContentStats(statsA: ContentStats, statsB: ContentStats) {\n  statsA.numWords += statsB.numWords\n  statsA.numImages += statsB.numImages\n}\n\nfunction countWordsInText(text: string): number {\n  if (!text) {\n    return 0\n  }\n\n  return (text.match(/\\w+/g) || []).length\n}\n\nfunction humanizeReadTime(time: number): string {\n  if (time < 0.5) {\n    return 'less than a minute'\n  }\n\n  if (time < 1.5) {\n    return '1 minute'\n  }\n\n  return `${Math.ceil(time)} minutes`\n}\n"],"mappings":"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","names":["getTextContent","text","_a","prev","current","getBlockCollectionId","block","recordMap","_a","_b","_c","_d","_e","_f","_g","collectionId","collectionViewId","collectionView","getBlockTitle","block","recordMap","_a","_b","getTextContent","collectionId","getBlockCollectionId","collection","getBlockIcon","block","recordMap","_a","_b","_c","collectionId","getBlockCollectionId","collection","getPageTitle","recordMap","_a","pageBlock","getBlockTitle","getPageProperty","propertyName","block","recordMap","_a","collection","propertyNameL","propertyId","key","_b","type","content","getTextContent","formatDate","start_date","start_time","end_date","end_time","startTime","endTime","e","getDateValue","prop","v","value","getBlockParentPage","block","recordMap","inclusive","_a","_b","currentRecord","parentId","parentTable","indentLevels","getPageTableOfContents","page","recordMap","_a","toc","blockId","_b","block","type","getTextContent","indentLevelStack","tocItem","indentLevel","actual","prevIndent","prevActual","prevEffective","getPageContentBlockIds","recordMap","blockId","rootBlockId","contentBlockIds","addContentBlocks","_a","_b","_c","_d","block","content","type","properties","format","key","p","d","value","referenceId","idToUuid","id","pageIdRe","pageId2Re","parsePageId","id","uuid","match","idToUuid","match2","uuidToId","uuid","PQueue","getAllPagesInSpace","_0","_1","_2","__async","rootPageId","rootSpaceId","getPage","concurrency","traverseCollections","targetPageId","pages","pendingPageIds","queue","PQueue","processPage","pageId","parsePageId","_a","_b","page","spaceId","key","block","subPageId","collectionViews","collectionData","blockIds","collectionItemId","err","normalizeTitle","title","getCanonicalPageId","pageId","recordMap","uuid","_a","id","uuidToId","block","slug","getPageProperty","normalizeTitle","getBlockTitle","getPageBreadcrumbs","recordMap","activePageId","_a","blockMap","breadcrumbs","currentPageId","block","title","getBlockTitle","icon","getBlockIcon","parentBlock","getBlockParentPage","parentId","isUrl","getPageImageUrls","recordMap","mapImageUrl","imageUrls","blockId","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","block","images","source","pageIcon","getBlockIcon","isUrl","url","mem","normalizeUrlImpl","normalizeUrl","url","u","subUrl","normalizedSubUrl","err","mergeRecordMaps","recordMapA","recordMapB","__spreadValues","formatDate","input","month","date","formatNotionDateTime","datetime","dateString","formatDate","estimatePageReadTime","block","recordMap","wordsPerMinute","imageReadTimeInSeconds","stats","getBlockContentStats","totalWordsReadTimeInMinutes","totalImageReadTimeInMinutes","totalReadTimeInMinutes","__spreadProps","__spreadValues","estimatePageReadTimeAsHumanizedString","opts","estimate","humanizeReadTime","_a","_b","_c","_d","childId","child","recurse","title","getBlockTitle","countWordsInText","page","toc","getPageTableOfContents","tocItem","referencePointerId","referenceBlock","mergeContentStats","statsA","statsB","text","time"]}
\ No newline at end of file
+{"version":3,"sources":["../src/get-text-content.ts","../src/get-block-collection-id.ts","../src/get-block-title.ts","../src/get-block-icon.ts","../src/get-page-title.ts","../src/get-page-property.ts","../src/get-date-value.ts","../src/get-block-parent-page.ts","../src/get-page-table-of-contents.ts","../src/get-page-content-block-ids.ts","../src/id-to-uuid.ts","../src/parse-page-id.ts","../src/uuid-to-id.ts","../src/get-all-pages-in-space.ts","../src/normalize-title.ts","../src/get-canonical-page-id.ts","../src/get-page-breadcrumbs.ts","../src/is-url.ts","../src/get-page-image-urls.ts","../src/normalize-url.ts","../src/merge-record-maps.ts","../src/format-date.ts","../src/format-notion-date-time.ts","../src/estimate-page-read-time.ts"],"sourcesContent":["import * as types from 'notion-types'\n\n/**\n * Gets the raw, unformatted text content of a block's content value.\n *\n * This is useful, for instance, for extracting a block's `title` without any\n * rich text formatting.\n */\nexport const getTextContent = (text?: types.Decoration[]): string => {\n  if (!text) {\n    return ''\n  } else if (Array.isArray(text)) {\n    return (\n      text?.reduce(\n        (prev, current) =>\n          prev + (current[0] !== '⁍' && current[0] !== '‣' ? current[0] : ''),\n        ''\n      ) ?? ''\n    )\n  } else {\n    return text\n  }\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\n\nexport function getBlockCollectionId(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): string | null {\n  const collectionId =\n    (block as any).collection_id ||\n    (block as any).format?.collection_pointer?.id\n\n  if (collectionId) {\n    return collectionId\n  }\n\n  const collectionViewId = (block as any)?.view_ids?.[0]\n  if (collectionViewId) {\n    const collectionView = recordMap.collection_view?.[collectionViewId]?.value\n    if (collectionView) {\n      const collectionId = collectionView.format?.collection_pointer?.id\n      return collectionId\n    }\n  }\n\n  return null\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockCollectionId } from './get-block-collection-id'\nimport { getTextContent } from './get-text-content'\n\nexport function getBlockTitle(block: Block, recordMap: ExtendedRecordMap) {\n  if (block.properties?.title) {\n    return getTextContent(block.properties.title)\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return getTextContent(collection.name)\n      }\n    }\n  }\n\n  return ''\n}\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\n\nimport { getBlockCollectionId } from './get-block-collection-id'\n\nexport function getBlockIcon(block: Block, recordMap: ExtendedRecordMap) {\n  if ((block as PageBlock).format?.page_icon) {\n    return (block as PageBlock).format?.page_icon\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return collection.icon\n      }\n    }\n  }\n\n  return null\n}\n","import { ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\n\nexport function getPageTitle(recordMap: ExtendedRecordMap) {\n  const pageBlock = recordMap.block[Object.keys(recordMap.block)[0]]?.value\n\n  if (pageBlock) {\n    return getBlockTitle(pageBlock, recordMap)\n  }\n\n  return null\n}\n","import { Block, DateFormat, ExtendedRecordMap } from 'notion-types'\n\nimport { getTextContent } from './get-text-content'\n\n/**\n * Gets the value of a collection property for a given page (collection item).\n *\n * @param propertyName property name\n * @param block Page block, often be first block in blockMap\n * @param recordMap\n * @returns - The return value types will follow the following principles:\n *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)\n *  2. property is text-like will return `string`\n *  3. multi select property will return `string[]`\n *  4. checkbox property return `boolean`\n * @todo complete all no-text property type\n */\nexport function getPageProperty<\n  T = string | number | boolean | string[] | number[]\n>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T\nexport function getPageProperty(\n  propertyName: string,\n  block: Block,\n  recordMap: ExtendedRecordMap\n) {\n  try {\n    if (!block.properties || !Object.keys(recordMap.collection)) {\n      // console.warn(\n      //   `block ${block.id} has no properties or this recordMap has no collection record`\n      // )\n      return null\n    }\n\n    const collection = recordMap.collection[block.parent_id]?.value\n\n    if (collection) {\n      const propertyNameL = propertyName.toLowerCase()\n      const propertyId = Object.keys(collection.schema).find(\n        (key) => collection.schema[key]?.name?.toLowerCase() === propertyNameL\n      )\n\n      if (!propertyId) {\n        return null\n      }\n\n      const { type } = collection.schema[propertyId]\n      const content = getTextContent(block.properties[propertyId])\n\n      switch (type) {\n        case 'created_time':\n          return block.created_time\n\n        case 'multi_select':\n          return content.split(',')\n\n        case 'date': {\n          const property = block.properties[propertyId] as [['‣', [DateFormat]]]\n          const formatDate = property[0][1][0][1]\n\n          if (formatDate.type == 'datetime') {\n            return new Date(\n              `${formatDate.start_date} ${formatDate.start_time}`\n            ).getTime()\n          } else if (formatDate.type == 'date') {\n            return new Date(formatDate.start_date).getTime()\n          } else if (formatDate.type == 'datetimerange') {\n            const { start_date, start_time, end_date, end_time } = formatDate\n            const startTime = new Date(`${start_date} ${start_time}`).getTime()\n            const endTime = new Date(`${end_date} ${end_time}`).getTime()\n            return [startTime, endTime]\n          } else {\n            const startTime = new Date(formatDate.start_date).getTime()\n            const endTime = new Date(formatDate.end_date).getTime()\n            return [startTime, endTime]\n          }\n        }\n\n        case 'checkbox':\n          return content == 'Yes'\n\n        case 'last_edited_time':\n          return block.last_edited_time\n\n        default:\n          return content\n      }\n    }\n  } catch {\n    // ensure that no matter what, we don't throw errors because of an unexpected\n    // collection data format\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Attempts to find a valid date from a given property.\n */\nexport const getDateValue = (prop: any[]): types.FormattedDate | null => {\n  if (prop && Array.isArray(prop)) {\n    if (prop[0] === 'd') {\n      return prop[1]\n    } else {\n      for (const v of prop) {\n        const value = getDateValue(v)\n        if (value) {\n          return value\n        }\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Returns the parent page block containing a given page.\n *\n * Note that many times this will not be the direct parent block since\n * some non-page content blocks can contain sub-blocks.\n */\nexport const getBlockParentPage = (\n  block: types.Block,\n  recordMap: types.ExtendedRecordMap,\n  {\n    inclusive = false\n  }: {\n    inclusive?: boolean\n  } = {}\n): types.PageBlock | null => {\n  let currentRecord: types.Block | types.Collection = block\n\n  while (currentRecord != null) {\n    if (inclusive && (currentRecord as types.Block)?.type === 'page') {\n      return currentRecord as types.PageBlock\n    }\n\n    const parentId: string = currentRecord.parent_id\n    const parentTable = currentRecord.parent_table\n\n    if (!parentId) {\n      break\n    }\n\n    if (parentTable === 'collection') {\n      currentRecord = recordMap.collection[parentId]?.value\n    } else {\n      currentRecord = recordMap.block[parentId]?.value\n\n      if ((currentRecord as types.Block)?.type === 'page') {\n        return currentRecord as types.PageBlock\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\nimport { getTextContent } from './get-text-content'\n\nexport interface TableOfContentsEntry {\n  id: types.ID\n  type: types.BlockType\n  text: string\n  indentLevel: number\n}\n\nconst indentLevels = {\n  header: 0,\n  sub_header: 1,\n  sub_sub_header: 2\n}\n\n/**\n * Gets the metadata for a table of contents block by parsing the page's\n * H1, H2, and H3 elements.\n */\nexport const getPageTableOfContents = (\n  page: types.PageBlock,\n  recordMap: types.ExtendedRecordMap\n): Array<TableOfContentsEntry> => {\n  type MapResult = TableOfContentsEntry | null | MapResult[]\n\n  function mapContentToEntries (content?: string[]): MapResult[] {\n    return (content ?? [])\n      .map((blockId: string) => {\n        const block = recordMap.block[blockId]?.value\n\n        if (block) {\n          const { type } = block\n\n          if (\n            type === 'header' ||\n            type === 'sub_header' ||\n            type === 'sub_sub_header'\n          ) {\n            return {\n              id: blockId,\n              type,\n              text: getTextContent(block.properties?.title),\n              indentLevel: indentLevels[type]\n            }\n          }\n\n          if (type === 'transclusion_container') {\n            return mapContentToEntries(block.content)\n          }\n        }\n\n        return null\n      })\n  }\n\n  const toc = mapContentToEntries(page.content)\n    .flat()\n    .filter(Boolean) as Array<TableOfContentsEntry>\n\n  const indentLevelStack = [\n    {\n      actual: -1,\n      effective: -1\n    }\n  ]\n\n  // Adjust indent levels to always change smoothly.\n  // This is a little tricky, but the key is that when increasing indent levels,\n  // they should never jump more than one at a time.\n  for (const tocItem of toc) {\n    const { indentLevel } = tocItem\n    const actual = indentLevel\n\n    do {\n      const prevIndent = indentLevelStack[indentLevelStack.length - 1]\n      const { actual: prevActual, effective: prevEffective } = prevIndent\n\n      if (actual > prevActual) {\n        tocItem.indentLevel = prevEffective + 1\n        indentLevelStack.push({\n          actual,\n          effective: tocItem.indentLevel\n        })\n      } else if (actual === prevActual) {\n        tocItem.indentLevel = prevEffective\n        break\n      } else {\n        indentLevelStack.pop()\n      }\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true)\n  }\n\n  return toc\n}\n","import * as types from 'notion-types'\n\n/**\n * Gets the IDs of all blocks contained on a page starting from a root block ID.\n */\nexport const getPageContentBlockIds = (\n  recordMap: types.ExtendedRecordMap,\n  blockId?: string\n): string[] => {\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0]\n  const contentBlockIds = new Set<string>()\n\n  function addContentBlocks(blockId: string) {\n    if (contentBlockIds.has(blockId)) return\n    contentBlockIds.add(blockId)\n\n    const block = recordMap.block[blockId]?.value\n    if (!block) return\n\n    const { content, type, properties, format } = block\n    if (properties) {\n      // TODO: this needs some love, especially for resolving relation properties\n      // see this collection_view_page for an example: 8a586d253f984b85b48254da84465d23\n      for (const key of Object.keys(properties)) {\n        const p = properties[key]\n        p.map((d: any) => {\n          const value = d?.[0]?.[1]?.[0]\n          if (value?.[0] === 'p' && value[1]) {\n            addContentBlocks(value[1])\n          }\n        })\n\n        // [[\"‣\", [[\"p\", \"841918aa-f2a3-4d4c-b5ad-64b0f57c47b8\"]]]]\n        const value = p?.[0]?.[1]?.[0]\n\n        if (value?.[0] === 'p' && value[1]) {\n          addContentBlocks(value[1])\n        }\n      }\n    }\n\n    if (format) {\n      const referenceId = format.transclusion_reference_pointer?.id\n      if (referenceId) {\n        addContentBlocks(referenceId)\n      }\n    }\n\n    if (!content || !Array.isArray(content)) {\n      // no child content blocks to recurse on\n      return\n    }\n\n    if (blockId !== rootBlockId) {\n      if (type === 'page' || type === 'collection_view_page') {\n        // ignore the content of other pages and collections\n        return\n      }\n    }\n\n    for (const blockId of content) {\n      addContentBlocks(blockId)\n    }\n  }\n\n  addContentBlocks(rootBlockId)\n  return Array.from(contentBlockIds)\n}\n","export const idToUuid = (id = '') =>\n  `${id.substr(0, 8)}-${id.substr(8, 4)}-${id.substr(12, 4)}-${id.substr(\n    16,\n    4\n  )}-${id.substr(20)}`\n","import { idToUuid } from './id-to-uuid'\n\nconst pageIdRe = /\\b([a-f0-9]{32})\\b/\nconst pageId2Re =\n  /\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/\n\n/**\n * Robustly extracts the notion page ID from a notion URL or pathname suffix.\n *\n * Defaults to returning a UUID (with dashes).\n */\nexport const parsePageId = (\n  id: string | null = '',\n  { uuid = true }: { uuid?: boolean } = {}\n) => {\n  if (!id) {\n    return null\n  }\n\n  id = id.split('?')[0]\n  const match = id.match(pageIdRe)\n\n  if (match) {\n    return uuid ? idToUuid(match[1]) : match[1]\n  }\n\n  const match2 = id.match(pageId2Re)\n  if (match2) {\n    return uuid ? match2[1] : match2[1].replace(/-/g, '')\n  }\n\n  return null\n}\n","export const uuidToId = (uuid: string) => uuid.replace(/-/g, '')\n","import { ExtendedRecordMap, PageMap } from 'notion-types'\nimport PQueue from 'p-queue'\n\nimport { parsePageId } from './parse-page-id'\n\n/**\n * Performs a traversal over a given Notion workspace starting from a seed page.\n *\n * Returns a map containing all of the pages that are reachable from the seed\n * page in the space.\n *\n * If `rootSpaceId` is not defined, the space ID of the root page will be used\n * to scope traversal.\n *\n *\n * @param rootPageId - Page ID to start from.\n * @param rootSpaceId - Space ID to scope traversal.\n * @param getPage - Function used to fetch a single page.\n * @param opts - Optional config\n */\nexport async function getAllPagesInSpace(\n  rootPageId: string,\n  rootSpaceId: string | undefined,\n  getPage: (pageId: string) => Promise<ExtendedRecordMap>,\n  {\n    concurrency = 4,\n    traverseCollections = true,\n    targetPageId = null\n  }: {\n    concurrency?: number\n    traverseCollections?: boolean\n    targetPageId?: string\n  } = {}\n): Promise<PageMap> {\n  const pages: PageMap = {}\n  const pendingPageIds = new Set<string>()\n  const queue = new PQueue({ concurrency })\n\n  async function processPage(pageId: string) {\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\n      return\n    }\n\n    pageId = parsePageId(pageId) as string\n\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\n      pendingPageIds.add(pageId)\n\n      queue.add(async () => {\n        try {\n          if (\n            targetPageId &&\n            pendingPageIds.has(targetPageId) &&\n            pageId !== targetPageId\n          ) {\n            return\n          }\n\n          const page = await getPage(pageId)\n          if (!page) {\n            return\n          }\n\n          const spaceId = page.block[pageId]?.value?.space_id\n\n          if (spaceId) {\n            if (!rootSpaceId) {\n              rootSpaceId = spaceId\n            } else if (rootSpaceId !== spaceId) {\n              return\n            }\n          }\n\n          Object.keys(page.block)\n            .filter((key) => {\n              const block = page.block[key]?.value\n              if (!block) return false\n\n              if (\n                block.type !== 'page' &&\n                block.type !== 'collection_view_page'\n              ) {\n                return false\n              }\n\n              // the space id check is important to limit traversal because pages\n              // can reference pages in other spaces\n              if (\n                rootSpaceId &&\n                block.space_id &&\n                block.space_id !== rootSpaceId\n              ) {\n                return false\n              }\n\n              return true\n            })\n            .forEach((subPageId) => processPage(subPageId))\n\n          // traverse collection item pages as they may contain subpages as well\n          if (traverseCollections) {\n            for (const collectionViews of Object.values(\n              page.collection_query\n            )) {\n              for (const collectionData of Object.values(collectionViews)) {\n                const { blockIds } = collectionData\n\n                if (blockIds) {\n                  for (const collectionItemId of blockIds) {\n                    processPage(collectionItemId)\n                  }\n                }\n              }\n            }\n          }\n\n          pages[pageId] = page\n        } catch (err) {\n          console.warn(\n            'page load error',\n            { pageId, spaceId: rootSpaceId },\n            err.statusCode,\n            err.message\n          )\n          pages[pageId] = null\n        }\n\n        pendingPageIds.delete(pageId)\n      })\n    }\n  }\n\n  await processPage(rootPageId)\n  await queue.onIdle()\n\n  return pages\n}\n","export const normalizeTitle = (title?: string | null): string => {\n  return (title || '')\n    .replace(/ /g, '-')\n    .replace(\n      /[^a-zA-Z0-9-\\u4e00-\\u9FFF\\u3041-\\u3096\\u30A1-\\u30FC\\u3000-\\u303F]/g,\n      ''\n    )\n    .replace(/--/g, '-')\n    .replace(/-$/, '')\n    .replace(/^-/, '')\n    .trim()\n    .toLowerCase()\n}\n","import { ExtendedRecordMap } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\nimport { getPageProperty } from './get-page-property'\nimport { normalizeTitle } from './normalize-title'\nimport { uuidToId } from './uuid-to-id'\n\n/**\n * Gets the canonical, display-friendly version of a page's ID for use in URLs.\n */\nexport const getCanonicalPageId = (\n  pageId: string,\n  recordMap: ExtendedRecordMap,\n  { uuid = true }: { uuid?: boolean } = {}\n): string | null => {\n  if (!pageId || !recordMap) return null\n\n  const id = uuidToId(pageId)\n  const block = recordMap.block[pageId]?.value\n\n  if (block) {\n    const slug =\n      (getPageProperty('slug', block, recordMap) as string | null) ||\n      (getPageProperty('Slug', block, recordMap) as string | null) ||\n      normalizeTitle(getBlockTitle(block, recordMap))\n\n    if (slug) {\n      if (uuid) {\n        return `${slug}-${id}`\n      } else {\n        return slug\n      }\n    }\n  }\n\n  return id\n}\n","import * as types from 'notion-types'\n\nimport { getBlockIcon } from './get-block-icon'\nimport { getBlockParentPage } from './get-block-parent-page'\nimport { getBlockTitle } from './get-block-title'\n\nexport const getPageBreadcrumbs = (\n  recordMap: types.ExtendedRecordMap,\n  activePageId: string\n): Array<any> | null => {\n  const blockMap = recordMap.block\n  const breadcrumbs = []\n\n  let currentPageId = activePageId\n\n  do {\n    const block = blockMap[currentPageId]?.value\n    if (!block) {\n      break\n    }\n\n    const title = getBlockTitle(block, recordMap)\n    const icon = getBlockIcon(block, recordMap)\n\n    if (!(title || icon)) {\n      break\n    }\n\n    breadcrumbs.push({\n      block,\n      active: currentPageId === activePageId,\n      pageId: currentPageId,\n      title,\n      icon\n    })\n\n    const parentBlock = getBlockParentPage(block, recordMap)\n    const parentId = parentBlock?.id\n\n    if (!parentId) {\n      break\n    }\n\n    currentPageId = parentId\n\n    // eslint-disable-next-line no-constant-condition\n  } while (true)\n\n  breadcrumbs.reverse()\n\n  return breadcrumbs\n}\n","import isUrl from 'is-url-superb'\n\nexport { isUrl }\n","import * as types from 'notion-types'\n\nimport { getBlockIcon } from './get-block-icon'\nimport { isUrl } from './is-url'\n\n/**\n * Gets URLs of all images contained on the given page.\n */\nexport const getPageImageUrls = (\n  recordMap: types.ExtendedRecordMap,\n  {\n    mapImageUrl\n  }: {\n    mapImageUrl: (url: string, block: types.Block) => string | null\n  }\n): string[] => {\n  const blockIds = Object.keys(recordMap.block)\n  const imageUrls: string[] = blockIds\n    .flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n      const images: Array<{ block: types.Block; url: string }> = []\n\n      if (block) {\n        if (block.type === 'image') {\n          const signedUrl = recordMap.signed_urls?.[block.id]\n          let source = signedUrl || block.properties?.source?.[0]?.[0]\n          if (source.includes('file.notion.so')) {\n            source = block.properties?.source?.[0]?.[0]\n          }\n\n          if (source) {\n            images.push({\n              block,\n              url: source\n            })\n          }\n        }\n\n        if ((block.format as any)?.page_cover) {\n          const source = (block.format as any).page_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_cover) {\n          const source = (block.format as any).bookmark_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_icon) {\n          const source = (block.format as any).bookmark_icon\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        const pageIcon = getBlockIcon(block, recordMap)\n        if (pageIcon && isUrl(pageIcon)) {\n          images.push({\n            block,\n            url: pageIcon\n          })\n        }\n      }\n\n      return images\n    })\n    .filter(Boolean)\n    .map(({ block, url }) => mapImageUrl(url, block))\n    .filter(Boolean)\n\n  return Array.from(new Set(imageUrls))\n}\n","import mem from 'mem'\nimport normalizeUrlImpl from 'normalize-url'\n\nexport const normalizeUrl = mem((url?: string) => {\n  if (!url) {\n    return ''\n  }\n\n  try {\n    if (url.startsWith('https://www.notion.so/image/')) {\n      const u = new URL(url)\n      const subUrl = decodeURIComponent(u.pathname.substr('/image/'.length))\n      const normalizedSubUrl = normalizeUrl(subUrl)\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`\n      url = u.toString()\n    }\n\n    return normalizeUrlImpl(url, {\n      stripProtocol: true,\n      stripWWW: true,\n      stripHash: true,\n      stripTextFragment: true,\n      removeQueryParameters: true\n    })\n  } catch (err) {\n    return ''\n  }\n})\n","import { ExtendedRecordMap } from 'notion-types'\n\nexport function mergeRecordMaps(\n  recordMapA: ExtendedRecordMap,\n  recordMapB: ExtendedRecordMap\n): ExtendedRecordMap {\n  const mergedRecordMap: ExtendedRecordMap = {\n    block: {\n      ...recordMapA.block,\n      ...recordMapB.block\n    },\n    collection: {\n      ...recordMapA.collection,\n      ...recordMapB.collection\n    },\n    collection_view: {\n      ...recordMapA.collection_view,\n      ...recordMapB.collection_view\n    },\n    notion_user: {\n      ...recordMapA.notion_user,\n      ...recordMapB.notion_user\n    },\n    collection_query: {\n      ...recordMapA.collection_query,\n      ...recordMapB.collection_query\n    },\n    signed_urls: {\n      ...recordMapA.signed_urls,\n      ...recordMapB.signed_urls\n    },\n    preview_images: {\n      ...recordMapA.preview_images,\n      ...recordMapB.preview_images\n    }\n  }\n\n  return mergedRecordMap\n}\n","export const formatDate = (\n  input: string | number,\n  { month = 'short' }: { month?: 'long' | 'short' } = {}\n) => {\n  const date = new Date(input)\n  const monthLocale = date.toLocaleString('en-US', { month })\n  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`\n}\n","import { formatDate } from './format-date'\n\nexport interface NotionDateTime {\n  type: 'datetime'\n  start_date: string\n  start_time?: string\n  time_zone?: string\n}\n\nexport const formatNotionDateTime = (datetime: NotionDateTime) => {\n  const dateString = `${datetime.start_time || ''} ${datetime.start_date} ${\n    datetime.time_zone || ''\n  }`\n  return formatDate(dateString)\n}\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\n\nimport { getBlockTitle } from './get-block-title'\nimport { getPageTableOfContents } from './get-page-table-of-contents'\n\ntype EstimatePageReadTimeOptions = {\n  wordsPerMinute?: number\n  imageReadTimeInSeconds?: number\n}\n\ntype ContentStats = {\n  numWords: number\n  numImages: number\n}\n\ntype PageReadTimeEstimate = ContentStats & {\n  totalWordsReadTimeInMinutes: number\n  totalImageReadTimeInMinutes: number\n  totalReadTimeInMinutes: number\n}\n\n/**\n * Returns an estimate for the time it would take for a person to read the content\n * in the given Notion page.\n *\n * Uses Medium for inspiration.\n *\n * @see https://blog.medium.com/read-time-and-you-bc2048ab620c\n * @see https://github.com/ngryman/reading-time\n *\n * TODO: handle non-english content.\n */\nexport function estimatePageReadTime(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  {\n    wordsPerMinute = 275,\n    imageReadTimeInSeconds = 12\n  }: EstimatePageReadTimeOptions = {}\n): PageReadTimeEstimate {\n  const stats = getBlockContentStats(block, recordMap)\n  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute\n  const totalImageReadTimeInSeconds =\n    stats.numImages > 10\n      ? (stats.numImages / 2) * (imageReadTimeInSeconds + 3) +\n        (stats.numImages - 10) * 3 // n/2(a+b) + 3 sec/image\n      : (stats.numImages / 2) *\n        (2 * imageReadTimeInSeconds + (1 - stats.numImages)) // n/2[2a+(n-1)d]\n  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60\n\n  const totalReadTimeInMinutes =\n    totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes\n\n  return {\n    ...stats,\n    totalWordsReadTimeInMinutes,\n    totalImageReadTimeInMinutes,\n    totalReadTimeInMinutes\n  }\n}\n\n/**\n * Same as `estimatePageReadTime`, except it returns the total time estimate as\n * a human-readable string.\n *\n * For example, \"9 minutes\" or \"less than a minute\".\n */\nexport function estimatePageReadTimeAsHumanizedString(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  opts: EstimatePageReadTimeOptions\n) {\n  const estimate = estimatePageReadTime(block, recordMap, opts)\n  return humanizeReadTime(estimate.totalReadTimeInMinutes)\n}\n\nfunction getBlockContentStats(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): ContentStats {\n  const stats: ContentStats = {\n    numWords: 0,\n    numImages: 0\n  }\n\n  if (!block) {\n    return stats\n  }\n\n  for (const childId of block.content || []) {\n    const child = recordMap.block[childId]?.value\n    let recurse = false\n    if (!child) continue\n\n    switch (child.type) {\n      case 'quote':\n      // fallthrough\n      case 'alias':\n      // fallthrough\n      case 'header':\n      // fallthrough\n      case 'sub_header':\n      // fallthrough\n      case 'sub_sub_header': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        break\n      }\n\n      case 'callout':\n      // fallthrough\n      case 'toggle':\n      // fallthrough\n      case 'to_do':\n      // fallthrough\n      case 'bulleted_list':\n      // fallthrough\n      case 'numbered_list':\n      // fallthrough\n      case 'text': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        recurse = true\n        break\n      }\n\n      case 'embed':\n      // fallthrough\n      case 'tweet':\n      // fallthrough\n      case 'maps':\n      // fallthrough\n      case 'pdf':\n      // fallthrough\n      case 'figma':\n      // fallthrough\n      case 'typeform':\n      // fallthrough\n      case 'codepen':\n      // fallthrough\n      case 'excalidraw':\n      // fallthrough\n      case 'gist':\n      // fallthrough\n      case 'video':\n      // fallthrough\n      case 'drive':\n      // fallthrough\n      case 'audio':\n      // fallthrough\n      case 'file':\n      // fallthrough\n      case 'image':\n        // treat all embeds as images\n        stats.numImages += 1\n        break\n\n      case 'bookmark':\n        // treat bookmarks as quarter images since they aren't as content-ful as embedd images\n        stats.numImages += 0.25\n        break\n\n      case 'code':\n        // treat code blocks as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'table':\n      // fallthrough\n      case 'collection_view':\n        // treat collection views as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'column':\n      // fallthrough\n      case 'column_list':\n      // fallthrough\n      case 'transclusion_container':\n        recurse = true\n        break\n\n      case 'table_of_contents': {\n        const page = block as PageBlock\n        if (!page) continue\n\n        const toc = getPageTableOfContents(page, recordMap)\n        for (const tocItem of toc) {\n          stats.numWords += countWordsInText(tocItem.text)\n        }\n\n        break\n      }\n\n      case 'transclusion_reference': {\n        const referencePointerId =\n          child?.format?.transclusion_reference_pointer?.id\n\n        if (!referencePointerId) {\n          continue\n        }\n        const referenceBlock = recordMap.block[referencePointerId]?.value\n        if (referenceBlock) {\n          mergeContentStats(\n            stats,\n            getBlockContentStats(referenceBlock, recordMap)\n          )\n        }\n        break\n      }\n\n      default:\n        // ignore unrecognized blocks\n        break\n    }\n\n    if (recurse) {\n      mergeContentStats(stats, getBlockContentStats(child, recordMap))\n    }\n  }\n\n  return stats\n}\n\nfunction mergeContentStats(statsA: ContentStats, statsB: ContentStats) {\n  statsA.numWords += statsB.numWords\n  statsA.numImages += statsB.numImages\n}\n\nfunction countWordsInText(text: string): number {\n  if (!text) {\n    return 0\n  }\n\n  return (text.match(/\\w+/g) || []).length\n}\n\nfunction humanizeReadTime(time: number): string {\n  if (time < 0.5) {\n    return 'less than a minute'\n  }\n\n  if (time < 1.5) {\n    return '1 minute'\n  }\n\n  return `${Math.ceil(time)} minutes`\n}\n"],"mappings":"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","names":["getTextContent","text","_a","prev","current","getBlockCollectionId","block","recordMap","_a","_b","_c","_d","_e","_f","_g","collectionId","collectionViewId","collectionView","getBlockTitle","block","recordMap","_a","_b","getTextContent","collectionId","getBlockCollectionId","collection","getBlockIcon","block","recordMap","_a","_b","_c","collectionId","getBlockCollectionId","collection","getPageTitle","recordMap","_a","pageBlock","getBlockTitle","getPageProperty","propertyName","block","recordMap","_a","collection","propertyNameL","propertyId","key","_b","type","content","getTextContent","formatDate","start_date","start_time","end_date","end_time","startTime","endTime","e","getDateValue","prop","v","value","getBlockParentPage","block","recordMap","inclusive","_a","_b","currentRecord","parentId","parentTable","indentLevels","getPageTableOfContents","page","recordMap","mapContentToEntries","content","blockId","_a","_b","block","type","getTextContent","toc","indentLevelStack","tocItem","indentLevel","actual","prevIndent","prevActual","prevEffective","getPageContentBlockIds","recordMap","blockId","rootBlockId","contentBlockIds","addContentBlocks","_a","_b","_c","_d","block","content","type","properties","format","key","p","d","value","referenceId","idToUuid","id","pageIdRe","pageId2Re","parsePageId","id","uuid","match","idToUuid","match2","uuidToId","uuid","PQueue","getAllPagesInSpace","_0","_1","_2","__async","rootPageId","rootSpaceId","getPage","concurrency","traverseCollections","targetPageId","pages","pendingPageIds","queue","PQueue","processPage","pageId","parsePageId","_a","_b","page","spaceId","key","block","subPageId","collectionViews","collectionData","blockIds","collectionItemId","err","normalizeTitle","title","getCanonicalPageId","pageId","recordMap","uuid","_a","id","uuidToId","block","slug","getPageProperty","normalizeTitle","getBlockTitle","getPageBreadcrumbs","recordMap","activePageId","_a","blockMap","breadcrumbs","currentPageId","block","title","getBlockTitle","icon","getBlockIcon","parentBlock","getBlockParentPage","parentId","isUrl","getPageImageUrls","recordMap","mapImageUrl","imageUrls","blockId","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","block","images","source","pageIcon","getBlockIcon","isUrl","url","mem","normalizeUrlImpl","normalizeUrl","url","u","subUrl","normalizedSubUrl","err","mergeRecordMaps","recordMapA","recordMapB","__spreadValues","formatDate","input","month","date","formatNotionDateTime","datetime","dateString","formatDate","estimatePageReadTime","block","recordMap","wordsPerMinute","imageReadTimeInSeconds","stats","getBlockContentStats","totalWordsReadTimeInMinutes","totalImageReadTimeInMinutes","totalReadTimeInMinutes","__spreadProps","__spreadValues","estimatePageReadTimeAsHumanizedString","opts","estimate","humanizeReadTime","_a","_b","_c","_d","childId","child","recurse","title","getBlockTitle","countWordsInText","page","toc","getPageTableOfContents","tocItem","referencePointerId","referenceBlock","mergeContentStats","statsA","statsB","text","time"]}